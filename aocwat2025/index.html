<!doctype html>
<script src="./libwabt.js"></script>
<script type="module" src="script.js?refetchplz"></script>
<link rel="stylesheet" href="style.css?refetchplz">
<title>AoC WAT 2025</title>

<h1>My <a href="https://adventofcode.com/">Advent of Code</a> 2025 solutions, made with <a href="https://webassembly.org/">WASM</a> text format</h1>
<a href="javascript:[...document.getElementsByTagName('details')].at(-1).scrollIntoView()">to bottom â†“</a>
<br />
<details>
    <summary>Day <glow>1</glow>: Secret Entrance</summary>
    This one wasn't too hard; it was the first day, after all.
    <br />
    Part 1 and 2 are basically the same, just where part 1 rotates e.g. left by 58 once,
    part 2 rotates left by one 58 times.
    <br />
    Not a <i>great</i> algorithm, but eh
    <wasm day="1" part="1"></wasm>
    <wasm day="1" part="2"></wasm>
</details>
<details>
    <summary>Day <glow>2</glow>: Gift Shop</summary>
    Part 1 of this wasn't very complex; had to do some funny math to check for repeating numbers but that was basically it. 
    <br />
    Part 2 did throw in some more complexity, but part 1's code was adaptable to it well enough.
    <wasm day="2" part="1"></wasm>
    <wasm day="2" part="2"></wasm>
</details>
<details>
    <summary>Day <glow>3</glow>: Lobby</summary>
    Part 1 of this got a brute-force solution: try every possible first digit with every possible end second digit.
    <br />
    Part 2 forced a more clever solution - I realized I didn't have to check every combo, as a larger first digit would <i>always</i> produce a bigger joltage; so I just had to check for the first largest number in range for each digit.
    <wasm day="3" part="1"></wasm>
    <wasm day="3" part="2"></wasm>
</details>
<details>
    <summary>Day <glow>4</glow>: Printing Department</summary>
    This one wasn't that bad with memory set up well; with the rows spaced out from eachother with a constant offset, I can just check e.g. 257 bytes back in memory and find the cell up and left in the grid.
    <br />
    Part 2 was just part 1 in a loop and removing rolls when counted.
    <wasm day="4" part="1"></wasm>
    <wasm day="4" part="2"></wasm>
</details>
<details>
    <summary>Day <glow>5</glow>: Cafeteria</summary>
    Part 1 wasn't too bad; scan the ranges into memory, then check each ingredient against all ranges until one works.
    <br />
    Part 2 was way harder, for three reasons: ranges could overlap, ingredients in two ranges should only be counted once, and going through the whole ingredient range manually would take hours even on the <i>best</i> CPUs. I did eventally come up with a solution I liked:
    <ol>
        <li>For each range, check if its end numbers are in any other range.</li>
        <li>If either end <i>is</i>, combine the two ranges in question by setting one range to the minimum minimum and the maximum maximum, and the other to 0-0 (which would be ignored later).</li>
        <li>If any range is combined, restart checks for the current range as to not accidentally miss a range that's now in reach.</li>
        <li>Once all ranges have been checked, none will overlap. Add up the sizes of all ranges +1, and return.</li>
    </ol>
    <wasm day="5" part="1"></wasm>
    <wasm day="5" part="2"></wasm>
</details>
<details>
    <summary>Day <glow>6</glow>: Trash Compactor</summary>
    Part 1 was pretty simple - just loaded each number into memory, recorded how long the row was, and read * and + to check what operation to do
    <br />
    The main change for part 2 was reading digits instead of numbers, and not skipping spaces. Then, I could iterate through each column, read the */+ conveniently positioned at the start of the problem, and read numbers down from the column.
    <br />
    For detecting blank columns, I could take advantage of the fact that zero doesn't appear anywhere in the input; so if I read a column as zero, it was definitely blank. 
    <wasm day="6" part="1"></wasm>
    <wasm day="6" part="2"></wasm>
</details>
<details open>
    <summary>Day <glow>7</glow>: Laboratories</summary>
    This one ended up pretty simple; keep a target row and a source row of memory, read the line, apply the correct behaviour, and swap rows for the next line.
    <br />
    Part 2 also had a simple solution; instead of writing 1, write the number of rays the space currently represents. The count of lasers at the end can be adapted from the split count, just start with 1 and add the number of rays split when a splitter is hit.
    <wasm day="7" part="1"></wasm>
    <wasm day="7" part="2"></wasm>
</details>

<div><br /></div> <!-- if the br isn't in a div it doesn't do anything apparently -->